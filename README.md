# Real-time Actor-based Message Exchange Network ğŸœ

[![Verification](https://github.com/Zubax/ramen/actions/workflows/verification.yml/badge.svg)](https://github.com/Zubax/ramen/actions/workflows/verification.yml)
[![Forum](https://img.shields.io/discourse/https/forum.zubax.com/users.svg?color=e00000)](https://forum.zubax.com)

RAMEN is a very compact, unopinionated, single-header C++20+ dependency-free library that implements
message-passing/[flow-based](https://en.wikipedia.org/wiki/Flow-based_programming)
programming for hard real-time mission-critical embedded systems, as well as general-purpose applications.
It is designed to be very low-overhead, efficient, and easy to use.

**To use the library in your project**, simply copy `ramen/ramen.hpp` into your project tree, `#include <ramen.hpp>`,
and you're ready to roll. Alternatively, add this repository as a submodule, and add `ramen/` to the include paths.

It should work on any conventional platform, from 8-bit to 64-bit; if you find this to be untrue, please open a ticket.

## Why though? ğŸ§

There exists a class of problems encountered in software engineering, particularly often in real-time control systems
and digital signal processing (DSP) pipelines, that are hard to model efficiently using more conventional paradigms,
such as OOP, but are easy to describe using the dataflow model.

Problems of that class are often found in embedded real-time control systems. One approach there is to use
model-based design with automatic code generation using LabView, Simulink, etc. The disadvantage of this approach
is that it may be difficult to couple autogenerated code with the rest of the system (such as the higher-level
control logic), as the resulting code tends to be extremely opinionated, strongly affecting the rest of the codebase.

RAMEN allows one to apply dataflow programming in an extremely unopinionated way, and it can be coupled with
conventional C/C++ programs ad-hoc. It is implemented in only a few hundred lines of straightforward C++, plus a couple 
more hundred lines for some useful utilities that are nice to have in a dataflow program.

RAMEN is typesafe, has no runtime errors, requires no heap, no exceptions, no RTTI, and adds no nontrivial 
computational complexity on top of the user logic.

## Notation ğŸ“

There are two way to arrange a dataflow:

- **Push model:** an actor receives data together with control flow and performs evaluations *eagerly*, updating its
  outputs immediately, triggering dependent computations downstream from itself.

- **Pull model:** an actor receives control when its outputs are needed, and fetches the data it needs *lazily*,
  triggering dependent computations upstream.

Any problem can be modeled using either approach, but some problems may be easier to model using only one or the
other. RAMEN supports both and allows mixing them if necessary (which should be done with caution, though).

RAMEN is built using only two primitive entities:

- **Behaviors** implement business logic, like methods in an OOP program. They contain completely arbitrary user 
  code, no strings attached. In the pull model, behaviors produce data, while in the push model they accept data.

- **Events** are used to notify other actors when new data is available (push aka eager model) or new data is 
  required for some computation (pull aka lazy model).

Events and behaviors are linked into *topics* using `operator>>`. When an event is triggered, all behaviors on the 
topic are executed. In the pull model, there should be only one behavior per topic to avoid ambiguity (otherwise, 
behavior executed later will overwrite the output computed by the earlier behaviors, which may not be what you need).
The push model allows mixing an arbitrary number of events and behaviors per topic; there, either of the connected 
events will trigger all behaviors (fanout).

Given that behaviors and ports can either sink or source data, we end up with four combinations:

| Port kind    | Control | Data | Alias      |
|--------------|---------|------|------------|
| in-behavior  | in      | in   | `Pushable` |
| out-event    | out     | out  | `Pusher`   |
| out-behavior | in      | out  | `Pullable` |
| in-event     | out     | in   | `Puller`   |

On a diagram, data inputs go on the left, data outputs on the right, and the direction of the control flow is shown
with an arrow:

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”
 (output data type) â”‚ Actor â”‚ (output data type)
  pushable â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â–º pusher
                    â”‚       â”‚
  (input data type) â”‚       â”‚ (output data type)
    puller â—„â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€ pullable
                    â””â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Dazzle me ğŸ¤¯

**For complete examples, refer to the `examples/` directory.**

Let's make a simple summation node using the pull model:

```
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
    (float) â”‚ Summer â”‚ (float)
 b â—„â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€ output
            â”‚        â”‚
    (float) â”‚        â”‚
 b â—„â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```c++
struct Summer
{
    ramen::Puller<float> in_a;
    ramen::Puller<float> in_b;
    ramen::Pullable<float> out_sum = [this](float& out) { out = *in_a + *in_b; };
};
```

We can see that the `Puller` entities are used to source the arguments from whatever external entity this summer is 
connected to. Crucially, the summer itself has no idea where the data is coming from. 

The data is read using `operator*` for convenience, but this will only work if the data type is default-constructible.
Sometimes it is not (e.g., `Eigen::MatrixRef` has to be bound to the storage matrix upon construction, so it is not 
default-constructible; this use case is very common in DSP), in which case the data is obtained using the ordinary 
function call syntax:

```c++
float a = 0;
in_a(a);

float b = 0;
in_b(b);

out = a + b;
```

This is also why we return the result via the out-parameter.

The summer can be linked to another actor using `operator>>`, where the direction of the operator arrow follows the 
direction of the control flow (not data flow). In the push model, they are the same, but in the pull model you need 
to remember that the arrow points against the direction of the data flow.

TODO...

## Development ğŸ§‘â€ğŸ’»

The `CMakeLists.txt` recipe is for development purposes only. Do not use in production.
